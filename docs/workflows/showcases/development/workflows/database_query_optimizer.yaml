$schema: "workflow/v2.0"
name: database_query_optimizer
version: 2.0.0
description: Identify N+1 queries, missing indexes, and database performance issues

execution:
  provider: anthropic
  model: claude-sonnet-4
  temperature: 0.3

steps:
  # Step 1: Analyze codebase for database queries
  - name: find_queries
    run: |
      Analyze this codebase for database queries:
      
      {{input}}
      
      Identify:
      
      **ORM/Database Framework:**
      - Framework: [Sequelize, TypeORM, SQLAlchemy, ActiveRecord, Prisma, etc.]
      - Database: [PostgreSQL, MySQL, MongoDB, etc.]
      
      **Query Patterns Found:**
      
      **Direct Queries:**
      - SQL queries in code
      - Location: [file:line]
      - Query: [the actual query]
      - Context: [what function/endpoint]
      
      **ORM Queries:**
      - Model operations (find, findAll, etc.)
      - Location: [file:line]
      - Operation: [what it does]
      - Context: [what function/endpoint]
      
      **Relationships:**
      - Model relationships defined
      - Foreign keys
      - Join tables
      - Eager vs lazy loading configured
      
      Return structured list of all database operations found.

  # Step 2: Identify N+1 query patterns
  - name: detect_n_plus_one
    needs: [find_queries]
    run: |
      Analyze for N+1 query problems:
      
      Queries Found:
      {{find_queries}}
      
      Code:
      {{input}}
      
      Look for N+1 patterns:
      
      **Pattern 1: Loop over results then query for each**
      ```
      users = User.findAll()
      for user in users:
          posts = Post.findByUserId(user.id)  # ❌ N+1!
      ```
      
      **Pattern 2: Accessing relationships without eager loading**
      ```
      users = User.findAll()  # No include
      for user in users:
          posts = user.posts  # ❌ N+1!
      ```
      
      **Pattern 3: Multiple queries in API endpoint**
      ```
      GET /api/users
        - Query 1: Get all users
        - Query 2-N: Get posts for each user  # ❌ N+1!
      ```
      
      For EACH N+1 problem found:
      
      **Location:** [file:line]
      **Severity:** [CRITICAL/HIGH/MEDIUM]
      **Pattern:** [Loop query / Lazy load / etc.]
      
      **Current Code:**
      ```
      [show problematic code]
      ```
      
      **Why it's N+1:**
      [Explain: 1 query to get users + N queries for each user = N+1 queries]
      
      **Impact:**
      - 100 users = 101 queries
      - Response time: [estimate]
      - Database load: [description]
      
      **Fix:**
      ```
      [show corrected code with eager loading or join]
      ```
      
      **Expected improvement:**
      - Queries: 101 → 1 (99% reduction)
      - Response time: [estimate improvement]

  # Step 3: Identify missing indexes
  - name: find_missing_indexes
    needs: [find_queries]
    run: |
      Analyze queries for missing indexes:
      
      Queries:
      {{find_queries}}
      
      For each query, check:
      
      **WHERE clause columns:**
      - Columns used in WHERE: [list]
      - Indexed? [check model definitions]
      - If not indexed: RECOMMEND INDEX
      
      **JOIN columns:**
      - Foreign key columns: [list]
      - Indexed? [check model definitions]
      - If not indexed: RECOMMEND INDEX
      
      **ORDER BY columns:**
      - Sort columns: [list]
      - Indexed? [check model definitions]
      - If not indexed: CONSIDER INDEX
      
      **Frequent queries:**
      - Queries in loops or high-traffic endpoints
      - Priority: HIGH for indexing
      
      For EACH missing index recommendation:
      
      **Table:** [name]
      **Column(s):** [name]
      **Query:** [example query that needs it]
      **Location:** [where query is used]
      **Priority:** [CRITICAL/HIGH/MEDIUM/LOW]
      
      **Why needed:**
      [Explain: This query does full table scan without index]
      
      **Impact without index:**
      - Table scan on [N] rows
      - Query time: O(n)
      - Scales poorly
      
      **SQL to create index:**
      ```sql
      CREATE INDEX idx_[table]_[column] ON [table]([column]);
      
      -- Or composite index if needed:
      CREATE INDEX idx_[table]_[col1]_[col2] ON [table]([col1], [col2]);
      ```
      
      **Expected improvement:**
      - Query time: O(n) → O(log n)
      - Estimate: [X]ms → [Y]ms

  # Step 4: Identify performance anti-patterns
  - name: find_antipatterns
    needs: [find_queries, detect_n_plus_one]
    run: |
      Identify database performance anti-patterns:
      
      Queries: {{find_queries}}
      N+1 Issues: {{detect_n_plus_one}}
      Code: {{input}}
      
      Check for:
      
      **1. SELECT * (all columns)**
      ```
      SELECT * FROM users  # ❌ Fetches unnecessary data
      
      # Better:
      SELECT id, name, email FROM users
      ```
      
      **2. Missing LIMIT on potentially large results**
      ```
      SELECT * FROM logs  # ❌ Could return millions
      
      # Better:
      SELECT * FROM logs LIMIT 100
      ```
      
      **3. Queries inside loops**
      ```
      for item in items:
          result = db.query(...)  # ❌ N queries
      
      # Better: Batch query outside loop
      ```
      
      **4. Large IN clauses**
      ```
      WHERE id IN (1,2,3...1000)  # ❌ Performance degrades
      
      # Better: Temporary table or batch queries
      ```
      
      **5. OR conditions preventing index use**
      ```
      WHERE col1 = X OR col2 = Y  # ❌ May not use indexes
      
      # Better: UNION or separate queries
      ```
      
      **6. Functions in WHERE clause**
      ```
      WHERE DATE(created_at) = '2024-01-01'  # ❌ Prevents index
      
      # Better: WHERE created_at >= '2024-01-01' AND created_at < '2024-01-02'
      ```
      
      **7. Missing connection pooling**
      [Check if database connections properly pooled]
      
      **8. Transactions not used where needed**
      [Check if operations that should be atomic use transactions]
      
      For each anti-pattern:
      - Location: [file:line]
      - Problem: [description]
      - Impact: [performance cost]
      - Fix: [recommendation]

  # Step 5: Generate optimization report
  - name: optimization_report
    needs: [detect_n_plus_one, find_missing_indexes, find_antipatterns]
    run: |
      Generate comprehensive database optimization report:
      
      # Database Query Optimization Report
      
      **Generated:** {{execution.timestamp}}
      **Workflow:** {{workflow.name}} v{{workflow.version}}
      
      ---
      
      ## Executive Summary
      
      **Database:** [from find_queries]
      **ORM/Framework:** [from find_queries]
      
      **Issues Found:**
      - N+1 Queries: [count]
      - Missing Indexes: [count]
      - Anti-patterns: [count]
      - Total: [count]
      
      **Estimated Performance Impact:**
      - Current query count: [estimate]
      - After optimization: [estimate]
      - Improvement: [percentage]
      
      ---
      
      ## Critical Issues (Fix Immediately)
      
      ### N+1 Query Problems
      
      {{detect_n_plus_one}}
      
      ### Missing Critical Indexes
      
      [Extract CRITICAL priority from find_missing_indexes]
      
      ---
      
      ## High Priority Issues (Fix This Sprint)
      
      ### Performance Anti-Patterns
      
      {{find_antipatterns}}
      
      ### Recommended Indexes
      
      [Extract HIGH priority from find_missing_indexes]
      
      ---
      
      ## Medium Priority (Schedule for Next Sprint)
      
      [Extract MEDIUM priority items]
      
      ---
      
      ## Low Priority (Technical Debt Backlog)
      
      [Extract LOW priority items]
      
      ---
      
      ## Implementation Plan
      
      ### Phase 1: Quick Wins (This Week)
      
      1. **Fix N+1 Queries**
         - [ ] [Location 1]: Add eager loading
         - [ ] [Location 2]: Use joins
         - Expected: 90% query reduction
      
      2. **Add Critical Indexes**
         - [ ] Run migration: [SQL]
         - Expected: 10× faster queries
      
      ### Phase 2: Systematic Improvements (This Month)
      
      1. **Refactor anti-patterns**
      2. **Add remaining indexes**
      3. **Implement query result caching**
      4. **Setup query monitoring**
      
      ### Phase 3: Ongoing (This Quarter)
      
      1. **Performance testing suite**
      2. **Query analysis in CI/CD**
      3. **Database monitoring alerts**
      
      ---
      
      ## SQL Scripts
      
      ### Index Creation
      
      ```sql
      -- Run these in order
      -- Backup database first!
      
      {{find_missing_indexes}}
      
      -- Verify indexes created:
      SHOW INDEX FROM [table];
      ```
      
      ### Query Improvements
      
      [List all optimized queries from detect_n_plus_one]
      
      ---
      
      ## Testing Plan
      
      **Before optimization:**
      1. Run load test on [endpoint]
      2. Record query count and response time
      3. Capture query logs
      
      **After optimization:**
      1. Re-run same load test
      2. Compare query count
      3. Verify response time improvement
      4. Check database CPU/memory
      
      **Expected Results:**
      - Query count: [before] → [after]
      - Response time: [before] → [after]
      - Database load: [before] → [after]
      
      ---
      
      ## Monitoring Recommendations
      
      **Setup alerts for:**
      - Queries taking >1 second
      - Endpoints making >10 queries
      - Full table scans
      - Missing indexes (slow query log)
      
      **Track metrics:**
      - Average queries per request
      - 95th percentile query time
      - Database connection pool usage
      - Cache hit rates
      
      ---
      
      ## ROI Analysis
      
      **Time Investment:**
      - Implement fixes: 8 hours
      - Testing: 2 hours
      - Total: 10 hours
      
      **Expected Benefits:**
      - 10× faster queries
      - 90% fewer queries
      - 50% reduction in database load
      - Better user experience
      - Lower infrastructure costs
      
      **Cost Savings:**
      - Reduced database CPU: $200/month
      - Faster responses: Better retention
      - Prevented scaling: $1000+/month
      
      **Total ROI:** 10 hours investment → $1200+/month savings

# Usage:
#
# Analyze entire codebase:
# ./mcp-cli --workflow database_query_optimizer \
#   --input-data "$(find src -name '*.py' -exec cat {} \;)"
#
# Analyze specific module:
# ./mcp-cli --workflow database_query_optimizer \
#   --input-data "$(cat app/models/*.js app/controllers/*.js)"
#
# Business Value:
# - Identify N+1 queries causing 100× slowdowns
# - Recommend indexes for 10× query speedup
# - Catch anti-patterns before production
# - Systematic optimization approach
# - Clear implementation plan with ROI
#
# ROI Calculation:
# - Manual code review: 16 hours × $150/hour = $2,400
# - Automated analysis: 5 minutes × $0.05 = $0.05
# - Savings: $2,399.95 per analysis (99.998%)
#
# Performance Impact:
# - Typical N+1 fix: 100 queries → 1 query (99% reduction)
# - Typical index: 1000ms → 10ms query (99% faster)
# - Combined: 10-100× overall performance improvement
#
# Ongoing Value:
# - Run on every major change
# - Prevent performance regressions
# - Database cost savings: $200-1000/month
# - Better user experience: Reduced churn
